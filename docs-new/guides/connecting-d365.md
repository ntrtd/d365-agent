# Guide: Connecting to Dynamics 365 Data via MCP Tools

This guide explains how the Dynamics 365 AI Agent SDK facilitates interaction with your Dynamics 365 environment, focusing on how **MCP Server tools** leverage type-safe OData clients to perform data operations.

## Core Concept: Generated OData Clients

The recommended approach for interacting with Dynamics 365 OData endpoints within your MCP Server implementation involves using **generated type-safe clients**. These clients provide several advantages:

*   **Type Safety:** Catch errors at compile time rather than runtime.
*   **IntelliSense/Autocompletion:** Improved developer experience when writing queries and code.
*   **Abstraction:** Simplifies the process of building OData queries and handling responses.

Separate generator projects exist to create these clients based on the D365 OData metadata (`$metadata`):

*   **TypeScript:** Uses tools like SAP Cloud SDK OData Generator or `odata2ts`.
*   **.NET:** Uses tools like OData Connected Service or `Microsoft.OData.Client.Design`.

These generators produce packages (npm for TS, NuGet for .NET) that are then consumed by your MCP Server project.

**Important:** For production environments or environments with customizations, you will need to regenerate the OData client using the specific `$metadata` from that environment to ensure all entities and fields are correctly represented.

## Option A: Using the TypeScript OData Client (in `d365-agent-mcpserver-ts` or similar)

This approach uses an OData client generated by tools like the SAP Cloud SDK OData Generator.

### 1. Consuming the Client Package

Install the generated client package (e.g., `@d365-agent/odataclient`) and the necessary SAP Cloud SDK connectivity library into your TypeScript MCP Server project:

```bash
npm install @your-org/d365-odata-client @sap-cloud-sdk/connectivity
# Replace @your-org/d365-odata-client with the actual package name
```

### 2. Authentication (Client Credentials Flow)

Authentication typically uses the OAuth 2.0 Client Credentials flow. You'll need to securely retrieve the D365 environment URL, Client ID, Client Secret, and Tenant ID (e.g., from Azure Key Vault) and configure an `HttpDestination`.

```typescript
// Example (Simplified - within an MCP tool or shared service)
import { HttpDestination } from "@sap-cloud-sdk/connectivity";
// Import function to fetch secrets securely
import { getD365Credentials } from './credentials'; 

async function getDestination(company: string): Promise<HttpDestination> {
    const creds = await getD365Credentials(company); // Fetch URL, ClientID, Secret, Tenant

    const destination: HttpDestination = {
        url: creds.url, // Base URL of D365 environment + '/data' path
        authentication: 'OAuth2ClientCredentials',
        clientId: creds.clientId,
        clientSecret: creds.clientSecret,
        tokenServiceUrl: `https://login.microsoftonline.com/${creds.tenantId}/oauth2/v2.0/token`,
        // Add Company query parameter if needed for D365 FO
        // URL should look like: https://your-d365-fo.operations.dynamics.com/data
        // For cross-company add `cross-company=true` query parameter if needed here or in requests
    };
    return destination;
}
```

### 3. Performing Operations

Import the generated API builders and entity types, obtain the destination, and execute requests using the fluent API.

**Querying Data:**

```typescript
// Example within an MCP Tool implementation
import { customersV3Api, CustomerV3 } from '@your-org/d365-odata-client';
import { z } from "zod";
// ... other imports including getDestination ...

// Assuming 'server' is the McpServer instance
server.tool(
  'getCustomerByNameTS',
  { customerName: z.string(), company: z.string() },
  async ({ customerName, company }) => {
    try {
      const destination = await getDestination(company);
      const customers = await customersV3Api
        .requestBuilder()
        .getAll()
        // Use the generated schema for type-safe filtering
        .filter(customersV3Api.schema.NAME.equals(customerName)) 
        .select(customersV3Api.schema.CUSTOMER_ACCOUNT, customersV3Api.schema.NAME)
        .top(1)
        // Execute the request against the configured destination
        .execute(destination); 

      const customer = customers[0];
      if (!customer) {
         return { content: [{ type: "text", text: `Customer '${customerName}' not found.` }] };
      }
      // Process and return result
      return { content: [{ type: "text", text: `Found: ${customer.Name} (Account: ${customer.CustomerAccount})` }] };
    } catch (error: any) {
      console.error("Error fetching customer:", error);
      // Return structured error for the orchestration layer
      return { content: [{ type: "text", text: `Error querying D365: ${error.message}` }], isError: true };
    }
  }
);
```

**Creating Data:**

```typescript
// Example: Creating a simple entity (assuming a 'notesApi' exists)
import { notesApi, Note } from '@your-org/d365-odata-client'; 
// ... inside an async MCP tool function ...
  const destination = await getDestination(company);
  const newNoteData: Note = { 
      // Populate required fields based on the generated Note type
      Subject: 'New Note from Agent', 
      Description: 'Details created via MCP tool.' 
      // ... other fields
  };
  const createdNote = await notesApi
      .requestBuilder()
      .create(newNoteData)
      .execute(destination);
  return { content: [{ type: "text", text: `Note created with ID: ${createdNote.NoteId}` }] }; // Assuming NoteId exists
```

**Updating Data:** (Requires entity key and ETag handling for concurrency)

```typescript
// Example: Updating an entity (requires knowing the key and often ETag)
import { customersV3Api } from '@your-org/d365-odata-client'; 
// ... inside an async MCP tool function ...
  const destination = await getDestination(company);
  const customerAccount = 'CUST-001'; // Key for the customer
  const updatePayload = { 
      // Only include fields to update
      PhoneNumber: '555-1234' 
  };

  // Note: SAP Cloud SDK requires the full entity usually, or specific update mechanisms.
  // This might involve fetching the entity first to get the ETag.
  // Simplified example assuming direct update is possible or handled by SDK layer:
  await customersV3Api
      .requestBuilder()
      .update(updatePayload) // This is conceptual; actual API might differ
      // Need to specify the key, e.g., .byKey(customerAccount, company) depending on generated client structure
      .execute(destination); // ETag handling might be needed

  return { content: [{ type: "text", text: `Customer ${customerAccount} updated.` }] };
```

**Deleting Data:** (Requires entity key)

```typescript
// Example: Deleting an entity
import { customersV3Api } from '@your-org/d365-odata-client'; 
// ... inside an async MCP tool function ...
  const destination = await getDestination(company);
  const customerAccount = 'CUST-002'; // Key for the customer

  await customersV3Api
      .requestBuilder()
      // Need to specify the key, e.g., .delete(customerAccount, company) depending on structure
      .delete(/* Keys */) // This is conceptual; actual API might differ
      .execute(destination); // ETag handling might be needed

  return { content: [{ type: "text", text: `Customer ${customerAccount} deleted.` }] };
```


## Option B: Using the .NET OData Client (in `d365-agent-mcpserver-dotnet` or similar)

This approach uses an OData client generated by tools like OData Connected Service.

### 1. Consuming the Client Package

Add the generated NuGet package containing the client classes to your .NET MCP Server project:

```powershell
dotnet add package Your.Generated.ODataClient.PackageName
# Replace with the actual package name
```

### 2. Authentication (Client Credentials Flow)

Instantiate the generated `DataServiceContext` and handle authentication by attaching the OAuth token to outgoing requests, typically using the `SendingRequest2` event.

```csharp
// Example Authentication Setup (e.g., in a service or tool base class)
using Microsoft.OData.Client;
using Your.Generated.ODataClient.Namespace; // Use your generated namespace
// Import helper to fetch secrets securely
using YourProject.Auth; 

public class D365Service
{
    private readonly ICredentialProvider _credentialProvider; // Service to get secrets

    public D365Service(ICredentialProvider credentialProvider)
    {
        _credentialProvider = credentialProvider;
    }

    public async Task<YourGeneratedDataServiceContext> CreateContextAsync(string company)
    {
        var creds = await _credentialProvider.GetD365CredentialsAsync(company);
        
        // Ensure URL includes /data endpoint
        Uri serviceRoot = new Uri(creds.Url.EndsWith("/data") ? creds.Url : $"{creds.Url.TrimEnd('/')}/data"); 
        
        var context = new YourGeneratedDataServiceContext(serviceRoot); // Replace with your actual context class name

        context.SendingRequest2 += async (sender, eventArgs) => {
            // Use a robust token caching mechanism in production
            var token = await GetOAuthTokenAsync(creds); 
            eventArgs.RequestMessage.SetHeader("Authorization", $"Bearer {token}");
        };
        
        // Optional: Handle D365 FO cross-company behavior
        // context.UrlConventions = DataServiceUrlConventions.KeyAsSegment; // Often needed for D365 FO
        // context.Configurations.RequestPipeline.OnEntryStarting((args) => {
        //     args.RequestUri = new Uri(args.RequestUri.OriginalString + "?cross-company=true"); // If needed globally
        // });

        return context;
    }

    private async Task<string> GetOAuthTokenAsync(D365Credentials creds)
    {
        // Use MSAL.NET library to acquire token using Client Credentials flow
        // Cache the token appropriately
        // Example using hypothetical MSAL helper:
        // return await MsalAuthHelper.GetTokenAsync(creds.TenantId, creds.ClientId, creds.ClientSecret, creds.Scope);
        await Task.Delay(10); // Placeholder
        return "DUMMY_TOKEN"; 
    }
}

// Placeholder for credentials structure
public class D365Credentials {
    public string Url { get; set; }
    public string ClientId { get; set; }
    public string ClientSecret { get; set; }
    public string TenantId { get; set; }
    public string Scope { get; set; } // e.g. https://your-d365-instance.operations.dynamics.com/.default
}
```

### 3. Performing Operations

Use LINQ queries against the `DataServiceContext` properties representing D365 entity sets.

**Querying Data:**

```csharp
// Example within an MCP Tool implementation
using Your.Generated.ODataClient.Namespace; 
using Microsoft.OData.Client;
using System.ComponentModel;
// ... other usings (MCP Server attributes, D365Service etc) ...

[McpServerToolType]
public static class CustomerToolsDotNet
{
    // Assume _d365Service is injected or available
    private static D365Service _d365Service = new D365Service(/* provide ICredentialProvider */);

    [McpServerTool, Description("Gets customer by name using .NET OData Client")]
    public static async Task<string> GetCustomerByNameDotNet(
        [Description("Customer Name")] string customerName,
        [Description("Company Code (e.g., 'usmf')")] string company)
    {
        try
        {
            var context = await _d365Service.CreateContextAsync(company);

            // Use LINQ to query the entity set (e.g., CustomersV3)
            DataServiceQuery<CustomerV3> query = context.CustomersV3 // Use the actual entity set name
                .AddQueryOption("$filter", $"Name eq '{Uri.EscapeDataString(customerName)}'")
                .AddQueryOption("$select", "CustomerAccount,Name") // Select specific fields
                .AddQueryOption("$top", "1") as DataServiceQuery<CustomerV3>;
            
            // Add cross-company if needed and not handled globally in context setup
            // query = query.AddQueryOption("cross-company", "true");

            // Execute asynchronously
            var customers = await Task.Factory.FromAsync(query.BeginExecute(null, null), (ar) => query.EndExecute(ar));
            var customer = customers.FirstOrDefault();

            if (customer == null)
            {
                 throw new McpException($"Customer '{customerName}' not found.");
            }
            // Process and return result (e.g., serialize to JSON)
            return System.Text.Json.JsonSerializer.Serialize(new { customer.CustomerAccount, customer.Name });
        }
        catch (Exception ex)
        {
            // Log error appropriately
            throw new McpException($"Error querying D365: {ex.Message}", ex);
        }
    }
}
```

**Creating Data:**

```csharp
// Example: Creating an entity
// ... inside an async MCP tool function ...
  var context = await _d365Service.CreateContextAsync(company);
  var newContact = new Contact { // Use generated Contact class
      FirstName = "Jane",
      LastName = "Smith",
      EMailAddress1 = "jane.smith@example.com"
      // ... set other required properties
  };

  context.AddToContacts(newContact); // Use AddTo<EntitySetName> method
  DataServiceResponse response = await Task.Factory.FromAsync(
      context.BeginSaveChanges(null, null), 
      (ar) => context.EndSaveChanges(ar)
  );

  // Check response for errors if necessary
  // Get created entity ID if needed (requires query or specific response handling)
  return "Contact created successfully."; // Simplified response
```

**Updating Data:**

```csharp
// Example: Updating an entity
// ... inside an async MCP tool function ...
  var context = await _d365Service.CreateContextAsync(company);
  var contactId = Guid.Parse("..."); // Key of the contact to update

  // Fetch the entity first to update it (best practice for tracking changes)
  var contactToUpdate = (await Task.Factory.FromAsync(
      context.Contacts.Where(c => c.ContactId == contactId).BeginExecute(null, null),
      (ar) => context.Contacts.EndExecute(ar)
  )).FirstOrDefault();

  if (contactToUpdate != null) 
  {
      contactToUpdate.EMailAddress1 = "j.smith@contoso.com";
      context.UpdateObject(contactToUpdate); // Mark object for update
      
      // Save changes with concurrency handling (e.g., If-Match header using ETag)
      DataServiceResponse response = await Task.Factory.FromAsync(
          context.BeginSaveChanges(SaveChangesOptions.ReplaceOnUpdate), // Or PatchWithChangeTracking
          (ar) => context.EndSaveChanges(ar)
      );
      return $"Contact {contactId} updated.";
  } else {
      throw new McpException($"Contact with ID {contactId} not found for update.");
  }
```

**Deleting Data:**

```csharp
// Example: Deleting an entity
// ... inside an async MCP tool function ...
  var context = await _d365Service.CreateContextAsync(company);
  var contactId = Guid.Parse("..."); // Key of the contact to delete

  // Fetch the entity first is often safer, or use AttachTo + DeleteObject if you only have the key
   var contactToDelete = (await Task.Factory.FromAsync(
      context.Contacts.Where(c => c.ContactId == contactId).BeginExecute(null, null),
      (ar) => context.Contacts.EndExecute(ar)
  )).FirstOrDefault();

  if (contactToDelete != null)
  {
      context.DeleteObject(contactToDelete);
      DataServiceResponse response = await Task.Factory.FromAsync(
          context.BeginSaveChanges(), 
          (ar) => context.EndSaveChanges(ar)
      );
      return $"Contact {contactId} deleted.";
  } else {
       throw new McpException($"Contact with ID {contactId} not found for deletion.");
  }
```

## Error Handling

When implementing MCP tools:

*   Wrap D365 client calls in `try...catch` blocks.
*   Log detailed errors on the server side.
*   Catch specific OData exceptions (e.g., `DataServiceQueryException`, `DataServiceClientException` in .NET) if possible.
*   Return meaningful, structured error messages (or throw `McpException`) back to the orchestration layer. Avoid leaking sensitive details.
*   Implement retry logic for transient network issues if appropriate.

By leveraging generated OData clients within your MCP Server tools, you can build robust and maintainable integrations with Dynamics 365.
